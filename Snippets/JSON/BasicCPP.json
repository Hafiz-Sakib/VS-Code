{
  "cpp snippets": {
    "prefix": "Sakib",
    "body": [
      "/*",
      "",
      "string author;",
      "author = Hafiz_Sakib;",
      "",
      "*/",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define endl \"\\n\"",
      "#define ll long long int",
      "#define vi vector<ll>",
      "#define yes cout<<\"YES\\n\"",
      "#define no cout<<\"NO\\n\"",
      "#define mod 1000000007",
      "#define ignore cin.ignore(numeric_limits<streamsize>::max(),'\\n')",
      "#define Boost ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)",
      "",
      "#define debug(x) cerr<<x<<endl;",
      "#define here fprintf(stderr, \"====I am Here====\\n\");",
      "",
      "",
      "void Boom()",
      "{",
      "$1",
      "}",
      "",
      "",
      "int main()",
      "{",
      "    Boost;",
      "",
      "    int t=1;",
      "    cin>>t;",
      "    while(t--)",
      "    {",
      "Boom();",
      "",
      "    }",
      "",
      "    return 0;",
      "",
      "}",
      ""
    ],
    "description": "to produce the main snippet for cpp"
  },
  "Foreach Loop": {
    "prefix": "foreach",
    "body": ["for(auto u : $1){", " ", "}"],
    "description": "to produce the foreach snippet for cpp"
  },

  "Comparator": {
    "prefix": "Comparator",
    "body": [
      "bool cmp(pair<int, int> a, pair<int, int> b)",
      "{",
      "    // first smaller,second greater",
      "    if (a.first < b.first)",
      "    {",
      "        return 1;",
      "    }",
      "    else if (a.first == b.first)",
      "    {",
      "        return a.second > b.second;",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "Comparator"
  },

  "Divisors": {
    "prefix": "Divisors",
    "body": [
      "vector<ll> Divisors;",
      "",
      "void Divisor(ll n)",
      "{",
      "    Divisors.clear();",
      "",
      "    for (int i = 1; (i * i) <= n; i++)",
      "    {",
      "        if (n % i == 0)",
      "        {",
      "            Divisors.push_back(i);",
      "            if (n / i != i)",
      "            {",
      "                Divisors.push_back(n / i);",
      "            }",
      "        }",
      "    }",
      "",
      "    sort(Divisors.begin(), Divisors.end());",
      "}"
    ],
    "description": "Divisors"
  },
  "OneToNDivisors": {
    "prefix": "OneToNDivisors",
    "body": [
      "",
      "vector<vector<ll>> Divisors(mx);",
      "",
      "void OneToNDivisors(ll n)",
      "{",
      "    for (int i = 1; i <= n; i++)",
      "    {",
      "        for (int j = i; j <= n; j += i)",
      "        {",
      "            Divisors[j].push_back(i);",
      "        }",
      "    }",
      "",
      "    // for (int i = 1; i <= n; i++)",
      "    // {",
      "    //     cout << i << \" : \";",
      "",
      "    //     for (auto u : Divisors[i])",
      "    //     {",
      "    //         cout << u << ' ';",
      "    //     }",
      "",
      "    //     cout << endl;",
      "    // }",
      "}"
    ],
    "description": "OneToNDivisors"
  },
  "NOD": {
    "prefix": "NOD",
    "body": [
      "int NOD(ll n)",
      "{",
      "    // This function will return how many divisors in (n) using Prime Factorization",
      "    int ans = 1;",
      "    // Call Sieve Function First",
      "    for (auto p : primes)",
      "    {",
      "        if (1LL * p * p > n)",
      "        {",
      "            break;",
      "        }",
      "        else if (n % p == 0)",
      "        {",
      "            int cnt = 1;",
      "            while (n % p == 0)",
      "            {",
      "                n /= p;",
      "                cnt++;",
      "            }",
      "            ans *= cnt;",
      "        }",
      "    }",
      "    if (n > 1)",
      "    {",
      "        ans *= 2;",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "NOD"
  },

  "SODSeries": {
    "prefix": "SODSeries",
    "body": [
      "ll SOD(ll n)",
      "{",
      "    ll ans = 1;",
      "    for (auto p : primes)",
      "    {",
      "        if (1LL * p * p > n)",
      "        {",
      "            break;",
      "        }",
      "        else if (n % p == 0)",
      "        {",
      "            ll CurrentSum = 1, PowerOfPrime = 1;",
      "            while (n % p == 0)",
      "            {",
      "                PowerOfPrime *= p;",
      "                CurrentSum += PowerOfPrime;",
      "                n /= p;",
      "            }",
      "            ans *= CurrentSum;",
      "        }",
      "    }",
      "    if (n > 1)",
      "    {",
      "        ans *= (n + 1);",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "SODSeries"
  },
  "SODFormula": {
    "prefix": "SODFormula",
    "body": [
      "ll SODFormula(ll n)",
      "{",
      "    ll ans = 1;",
      "    for (auto p : primes)",
      "    {",
      "        if (1LL * p * p > n)",
      "        {",
      "            break;",
      "        }",
      "        else if (n % p == 0)",
      "        {",
      "            ll CurrentSum = 1, PowerOfPrime = p;",
      "            while (n % p == 0)",
      "            {",
      "                PowerOfPrime *= p;",
      "                n /= p;",
      "            }",
      "            ans *= ((PowerOfPrime - 1) / (p - 1));",
      "        }",
      "    }",
      "    if (n > 1)",
      "    {",
      "        ans *= (n + 1);",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "SODFormula"
  },

  "SNOD": {
    "prefix": "SNOD",
    "body": [
      "ll SNOD(ll n)",
      "{",
      "    ll ans = 0, u = sqrt(n);",
      "    for (int i = 1; i <= u; i++)",
      "    {",
      "        ans += (n / i) - i;",
      "    }",
      "    ans *= 2;",
      "    ans += u;",
      "    return ans;",
      "}"
    ],
    "description": "Sum of Number of Divisors from 1 to N"
  },

  "isprime": {
    "prefix": "isprime",
    "body": [
      "bool isPrime(int n)",
      "{",
      "    if (n <= 1)",
      "        return false;",
      "    if (n <= 3)",
      "        return true;",
      "    if (n % 2 == 0 || n % 3 == 0)",
      "        return false;",
      "    for (int i = 5; i * i <= n; i = i + 6)",
      "        if (n % i == 0 || n % (i + 2) == 0)",
      "            return false;",
      "  ",
      "    return true;",
      "}"
    ],
    "description": "isprime"
  },
  "SieveOfEratosthenes": {
    "prefix": "sieve",
    "body": [
      "",
      "bitset<mx> is_prime;",
      "vector<int> primes;",
      "",
      "void Sieve(int n)",
      "{",
      "    for (int i = 3; i <= n; i += 2)",
      "    {",
      "        is_prime[i] = 1;",
      "    }",
      "",
      "    for (int i = 3; (i * i) <= n; i += 2)",
      "    {",
      "        if (is_prime[i])",
      "        {",
      "            for (int j = (i * i); j <= n; j += (i + i))",
      "            {",
      "                is_prime[j] = 0;",
      "            }",
      "        }",
      "    }",
      "",
      "    is_prime[1] = 0;",
      "    is_prime[2] = 1;",
      "    primes.push_back(2);",
      "",
      "    for (int i = 3; i <= n; i += 2)",
      "    {",
      "        if (is_prime[i])",
      "        {",
      "            primes.push_back(i);",
      "        }",
      "    }",
      "}",
      ""
    ],
    "description": ""
  },
  "primefactorization": {
    "prefix": "primefactorization",
    "body": [
      "vector<ll> PrimeFactors;",
      "",
      "void PrimeFactorization(ll n)",
      "{",
      "    PrimeFactors.clear();",
      "    // Call Sieve Function First",
      "    for (auto p : primes)",
      "    {",
      "        if (1LL * p * p > n)",
      "        {",
      "            break;",
      "        }",
      "        else if (n % p == 0)",
      "        {",
      "            while (n % p == 0)",
      "            {",
      "                PrimeFactors.push_back(p);",
      "                n /= p;",
      "            }",
      "        }",
      "    }",
      "    if (n > 1)",
      "    {",
      "        PrimeFactors.push_back(n);",
      "    }",
      "}"
    ],
    "description": "primefector"
  },
  "OneToNPrimeFactorization": {
    "prefix": "OneToNPrimeFactorization",
    "body": [
      "",
      "vector<vector<ll>> PrimeFactors(mx);",
      "",
      "void PrimeFactorization(ll n)",
      "{",
      "    // Call Sieve Function First",
      "    for (auto p : primes)",
      "    {",
      "        for (int i = p; i <= n; i += p)",
      "        {",
      "            PrimeFactors[i].push_back(p);",
      "        }",
      "    }",
      "",
      "    // for (int i = 1; i <= n; i++)",
      "    // {",
      "    //     cout << i << \" : \";",
      "    //     for (auto u : PrimeFactors[i])",
      "    //     {",
      "    //         cout << u << ' ';",
      "    //     }",
      "    //     cout << endl;",
      "    // }",
      "}"
    ],
    "description": "OneToNPrimeFactorization"
  },
  "ModularArithmetic": {
    "prefix": "ModularArithmetic",
    "body": [
      "void normal(ll &a)",
      "{",
      "    a %= mod;",
      "    (a < 0) && (a += mod);",
      "}",
      "ll modMul(ll a, ll b)",
      "{",
      "    a %= mod, b %= mod;",
      "    normal(a), normal(b);",
      "    return (a * b) % mod;",
      "}",
      "ll modAdd(ll a, ll b)",
      "{",
      "    a %= mod, b %= mod;",
      "    normal(a), normal(b);",
      "    return (a + b) % mod;",
      "}",
      "ll modSub(ll a, ll b)",
      "{",
      "    a %= mod, b %= mod;",
      "    normal(a), normal(b);",
      "    a -= b;",
      "    normal(a);",
      "    return a;",
      "}",
      "ll modPow(ll b, ll p)",
      "{",
      "    ll r = 1;",
      "    while (p)",
      "    {",
      "        if (p & 1)",
      "        {",
      "            r = modMul(r, b);",
      "        }",
      "        b = modMul(b, b);",
      "        p >>= 1;",
      "    }",
      "    return r;",
      "}",
      "ll modInverse(ll a)",
      "{",
      "    return modPow(a, mod - 2);",
      "}",
      "ll modDiv(ll a, ll b)",
      "{",
      "    return modMul(a, modInverse(b));",
      "}"
    ],
    "description": "ModularArithmetic"
  },
  "BinaryExponentiation": {
    "prefix": "BinaryExponentiation",
    "body": [
      "int BinaryExponentiation(int b, int p)",
      "{",
      "    int ans = 1;",
      "    while (p)",
      "    {",
      "        if (p & 1)",
      "        {",
      "            ans = (ans * 1LL * b) % mod;",
      "        }",
      "        b = (b * 1LL * b) % mod;",
      "        p >>= 1;",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "BinaryExponentiation"
  },
  "EulerPhiFunction": {
    "prefix": "EulerPhiFunction",
    "body": [
      "int EulerPhi(int n)",
      "{",
      "    int ans = n;",
      "    for (auto p : primes)",
      "    {",
      "        if (p * 1LL * p > n)",
      "        {",
      "            break;",
      "        }",
      "        if (n % p == 0)",
      "        {",
      "            ans /= p;",
      "            ans *= (p - 1);",
      "            while (n % p == 0)",
      "            {",
      "                n /= p;",
      "            }",
      "        }",
      "    }",
      "",
      "    if (n > 1)",
      "    {",
      "        ans /= n;",
      "        ans *= (n - 1);",
      "    }",
      "",
      "    return ans;",
      "}"
    ],
    "description": "EulerPhiFunction"
  },
  "Binary Search": {
    "prefix": "binarysrc",
    "body": [
      "int binarysrc(vector<int> v, int q)",
      "{",
      "    int first = 0;",
      "    int last = v.size() - 1;",
      "",
      "    while (first <= last)",
      "    {",
      "        int mid = (first + last) / 2;",
      "        if (q == v[mid])",
      "        {",
      "            return mid;",
      "        }",
      "        else if (v[mid] < q)",
      "        {",
      "            first = mid + 1;",
      "        }",
      "        else if (v[mid] > q)",
      "        {",
      "            last = mid - 1;",
      "        }",
      "    }",
      "    return -1;",
      "}",
      ""
    ],
    "description": "Binary Search"
  },
  "Upper Bound": {
    "prefix": "upperbound",
    "body": [
      "int upperbound(vector<int> v, int q)",
      "{",
      "    int l = 0, r = v.size() - 1, ans = v.size();",
      "    while (l <= r)",
      "    {",
      "        int mid = (l + r) >> 1;",
      "        if (v[mid] <= q)",
      "        {",
      "            l = mid + 1;",
      "        }",
      "        else",
      "        {",
      "            ans = min(ans, mid);",
      "            r = mid - 1;",
      "        }",
      "    }",
      "    return ans;",
      "}",
      ""
    ],
    "description": "Upper Bound"
  },
  "Lower Bound": {
    "prefix": "lowerbound",
    "body": [
      "int lowerbound(vector<int> v, int q)",
      "{",
      "    int l = 0, r = v.size() - 1, ans = v.size();",
      "    while (l <= r)",
      "    {",
      "        int mid = (l + r) >> 1;",
      "        if (v[mid] >= q)",
      "        {",
      "            ans = min(ans, mid);",
      "            r = mid - 1;",
      "        }",
      "        else",
      "        {",
      "            l = mid + 1;",
      "        }",
      "    }",
      "    return ans;",
      "}",
      ""
    ],
    "description": "Lower Bound"
  }
}
