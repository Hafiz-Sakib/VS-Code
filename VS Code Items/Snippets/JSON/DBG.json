{
  "Template": {
    "prefix": "Sakib",
    "body": [
      "//Bismillahir Rahmanir Rahim",
      "/*",
      "",
      "string author;",
      "author = Hafiz_Sakib;",
      "",
      "*/",
      "#include<bits/stdc++.h>",
      "using namespace std;",
      "",
      "",
      "typedef long long int ll;",
      "typedef  unsigned long long ull;",
      "",
      "",
      "typedef vector<ll> vi;",
      "typedef vector<double> vd;",
      "typedef vector<string> vs;",
      "typedef vector<char> vc;",
      "typedef vector<vector<ll>> vvi;",
      "typedef vector<pair<ll, ll>> vpii;",
      "typedef vector<pair<string, ll>> vpsi;",
      "typedef pair<ll , ll> pii;",
      "typedef pair<string, ll> psi;",
      "typedef pair<ll, string> pis;",
      "typedef pair<double, double> pdd;",
      "typedef map<ll, ll> mii;",
      "typedef map<ll, bool> mib;",
      "typedef map<string, ll> msi;",
      "typedef map<ll, string> mis;",
      "typedef set<ll> si;",
      "typedef set<char> sc;",
      "typedef set<string> ss;",
      "typedef set<double> sd;",
      "typedef priority_queue<ll> pq;",
      "typedef priority_queue<string> pqs;",
      "typedef priority_queue<ll, vi, greater<ll>> pqg;",
      "",
      "typedef vector<int>::iterator vit;",
      "typedef set<int>::iterator sit;",
      "",
      "#define pb push_back",
      "#define mp make_pair",
      "#define pob pop_back",
      "#define in insert",
      "#define fi first",
      "#define se second",
      "#define space ' '",
      "#define endl \"\\n\"",
      "#define lb lower_bound",
      "#define ub upper_bound",
      "",
      "#define left(node) (node * 2)",
      "#define mid(l, r) ((r + l) >> 1)",
      "#define right(node) (node * 2 + 1)",
      "",
      "#define b() begin()",
      "#define e() end()",
      "#define sz(x) (int)x.size()",
      "#define all(data) data.begin(),data.end()",
      "#define rall(data) data.rbegin(),data.rend()",
      "#define Reverse(data) reverse(data.begin(), data.end())",
      "#define vecMax(data) *max_element(data.begin(), data.end())",
      "#define vecMin(data) *min_element(data.begin(), data.end())",
      "#define vecSum(data) accumulate(data.begin(), data.end(), 0)",
      "#define vecCount(data, key) count(data.begin(), data.end(), key)",
      "",
      "#define yes cout<<\"YES\\n\"",
      "#define no cout<<\"NO\\n\"",
      "#define YES cout<<\"Yes\\n\"",
      "#define NO cout<<\"No\\n\"",
      "",
      "#define setp(n) fixed << setprecision(n)",
      "#define fr(a, b) for (int i = a; i < b; i++)",
      "#define rep(i, a, b) for (int i = a; i < b; i++)",
      "#define mem(arr,val) memset(arr,val,sizeof(arr));",
      "#define ignore cin.ignore(numeric_limits<streamsize>::max(),'\\n')",
      "#define FOR(data) for(auto it=data.begin();it!=data.end();it++)",
      "#define stringLower(data) transform(data.begin(), data.end(), data.begin(), ::tolower)",
      "#define stringUpper(data) transform(data.begin(), data.end(), data.begin(), ::toupper)",
      "",
      "#define gcd(a,b) __gcd(a,b)",
      "#define lcm(a, b) ((a)/gcd(a, b)*(b))",
      "#define sqr(a) ((a) * (a))",
      "#define mod 1000000007",
      "#define mx_int_prime 999999937",
      "",
      "const double PI = acos(-1);",
      "const int mx = 1e8+123;",
      "const double eps = 1e-12;",
      "const int inf = 2000000000;",
      "const ll infLL = 9000000000000000000;",
      "",
      "#define Boost ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)",
      "",
      "",
      "//Debugger Started",

      "#define here fprintf(stderr, \"====I am Here====\\n\");",

      "template < typename F, typename S >",
      "ostream& operator << ( ostream& os, const pair< F, S > & p ) {",
      "            return os << \"(\" << p.first << \", \" << p.second << \")\";",
      "}",
      " ",
      "template < typename T >",
      "ostream &operator << ( ostream & os, const vector< T > &v ) {",
      "            os << \"{\";",
      "                for(auto it = v.begin(); it != v.end(); ++it) {",
      "                                if( it != v.begin() ) os << \", \";",
      "                                        os << *it;",
      "                                            }",
      "                    return os << \"}\";",
      "}",
      " ",
      "template < typename T >",
      "ostream &operator << ( ostream & os, const set< T > &v ) {",
      "            os << \"[\";",
      "                for(auto it = v.begin(); it != v.end(); ++it) {",
      "                                if( it != v.begin() ) os << \", \";",
      "                                        os << *it;",
      "                                            }",
      "                    return os << \"]\";",
      "}",
      " ",
      "template < typename T >",
      "ostream &operator << ( ostream & os, const multiset< T > &v ) {",
      "            os << \"[\";",
      "                for(auto it = v.begin(); it != v.end(); ++it) {",
      "                                if( it != v.begin() ) os << \", \";",
      "                                        os << *it;",
      "                                            }",
      "                    return os << \"]\";",
      "}",
      " ",
      "template < typename F, typename S >",
      "ostream &operator << ( ostream & os, const map< F, S > &v ) {",
      "            os << \"[\";",
      "                for(auto it = v.begin(); it != v.end(); ++it) {",
      "                                if( it != v.begin() ) os << \", \";",
      "                                        os << it -> first << \" = \" << it -> second ;",
      "                                            }",
      "                    return os << \"]\";",
      "}",
      " ",
      "#define debug(args...) do {cerr << #args << \" : \"; faltu(args); } while(0)",
      " ",
      "void faltu () {",
      "            cerr << endl;",
      "}",
      " ",
      "template <typename T>",
      "void faltu( T a[], int n ) {",
      "            for(int i = 0; i < n; ++i) cerr << a[i] << ' ';",
      "                cerr << endl;",
      "}",
      " ",
      "template <typename T, typename ... hello>",
      "void faltu( T arg, const hello &... rest) {",
      "            cerr << arg << ' ';",
      "                faltu(rest...);",
      "}",

      "//Debugger Ends",

      "",
      "",
      "",
      "void Boom()",
      "{",
      "    //Let's Move",
      "    $2",
      "}",
      "",
      "int main()",
      "{",
      "    Boost;",
      "",
      "    int t=1;",
      "    cin>>t;",
      "    while(t--)",
      "    {",
      "        //cout<<\"Case \"<<t<<\" : \";$1",
      "        Boom();",
      "    }",
      "",
      "    return 0;",
      "",
      "}",
      ""
    ],
    "description": "Template"
  },

  "ceil": {
    "prefix": "ceil",
    "body": [
      "ll int ceil(ll int x,ll int y)",
      "{",
      "    return (x+(y-1))/y;",
      "}   "
    ],
    "description": "ceil"
  },

  "Foreach Loop": {
    "prefix": "foreach",
    "body": ["for(auto u : $1){", " ", "}"],
    "description": "to produce the foreach snippet for cpp"
  },

  "round": {
    "prefix": "round",
    "body": [
      "ll int round(ll int x,ll int y)",
      "{",
      "return ((x+y)/2)/y;",
      "}"
    ],
    "description": "round"
  },
  "strtoint": {
    "prefix": "strtoint",
    "body": ["stringstream geek(str);", "int intr;", "geek >> intr;"],
    "description": "strtoint"
  },
  "token": {
    "prefix": "token",
    "body": [
      "stringstream stream(str);",
      "string tok;",
      "while(getline(stream, tok, ' '))",
      "{",
      "cout<<tok<<endl;",
      "}"
    ],
    "description": "token"
  },
  "unique": {
    "prefix": "unique",
    "body": [
      "vector<int>::iterator ip;",
      "ip = unique(data.begin(),data.end());",
      "data.resize(distance(data.begin(), ip));",
      "cout<<data.size()<<endl;"
    ],
    "description": "unique"
  },

  "Comparator": {
    "prefix": "Comparator",
    "body": [
      "bool cmp(pair<int, int> a, pair<int, int> b)",
      "{",
      "    // first smaller,second greater",
      "    if (a.first < b.first)",
      "    {",
      "        return 1;",
      "    }",
      "    else if (a.first == b.first)",
      "    {",
      "        return a.second > b.second;",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "Comparator"
  },

  "Divisors": {
    "prefix": "Divisors",
    "body": [
      "vector<ll> Divisors;",
      "",
      "void Divisor(ll n)",
      "{",
      "    Divisors.clear();",
      "",
      "    for (int i = 1; (i * i) <= n; i++)",
      "    {",
      "        if (n % i == 0)",
      "        {",
      "            Divisors.push_back(i);",
      "            if (n / i != i)",
      "            {",
      "                Divisors.push_back(n / i);",
      "            }",
      "        }",
      "    }",
      "",
      "    sort(Divisors.begin(), Divisors.end());",
      "}"
    ],
    "description": "Divisors"
  },
  "OneToNDivisors": {
    "prefix": "OneToNDivisors",
    "body": [
      "",
      "vector<vector<ll>> Divisors(mx);",
      "",
      "void OneToNDivisors(ll n)",
      "{",
      "    for (int i = 1; i <= n; i++)",
      "    {",
      "        for (int j = i; j <= n; j += i)",
      "        {",
      "            Divisors[j].push_back(i);",
      "        }",
      "    }",
      "",
      "    // for (int i = 1; i <= n; i++)",
      "    // {",
      "    //     cout << i << \" : \";",
      "",
      "    //     for (auto u : Divisors[i])",
      "    //     {",
      "    //         cout << u << ' ';",
      "    //     }",
      "",
      "    //     cout << endl;",
      "    // }",
      "}"
    ],
    "description": "OneToNDivisors"
  },
  "NOD": {
    "prefix": "NOD",
    "body": [
      "int NOD(ll n)",
      "{",
      "    // This function will return how many divisors in (n) using Prime Factorization",
      "    int ans = 1;",
      "    // Call Sieve Function First",
      "    for (auto p : primes)",
      "    {",
      "        if (1LL * p * p > n)",
      "        {",
      "            break;",
      "        }",
      "        else if (n % p == 0)",
      "        {",
      "            int cnt = 1;",
      "            while (n % p == 0)",
      "            {",
      "                n /= p;",
      "                cnt++;",
      "            }",
      "            ans *= cnt;",
      "        }",
      "    }",
      "    if (n > 1)",
      "    {",
      "        ans *= 2;",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "NOD"
  },

  "SODSeries": {
    "prefix": "SODSeries",
    "body": [
      "ll SOD(ll n)",
      "{",
      "    ll ans = 1;",
      "    for (auto p : primes)",
      "    {",
      "        if (1LL * p * p > n)",
      "        {",
      "            break;",
      "        }",
      "        else if (n % p == 0)",
      "        {",
      "            ll CurrentSum = 1, PowerOfPrime = 1;",
      "            while (n % p == 0)",
      "            {",
      "                PowerOfPrime *= p;",
      "                CurrentSum += PowerOfPrime;",
      "                n /= p;",
      "            }",
      "            ans *= CurrentSum;",
      "        }",
      "    }",
      "    if (n > 1)",
      "    {",
      "        ans *= (n + 1);",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "SODSeries"
  },
  "SODFormula": {
    "prefix": "SODFormula",
    "body": [
      "ll SODFormula(ll n)",
      "{",
      "    ll ans = 1;",
      "    for (auto p : primes)",
      "    {",
      "        if (1LL * p * p > n)",
      "        {",
      "            break;",
      "        }",
      "        else if (n % p == 0)",
      "        {",
      "            ll CurrentSum = 1, PowerOfPrime = p;",
      "            while (n % p == 0)",
      "            {",
      "                PowerOfPrime *= p;",
      "                n /= p;",
      "            }",
      "            ans *= ((PowerOfPrime - 1) / (p - 1));",
      "        }",
      "    }",
      "    if (n > 1)",
      "    {",
      "        ans *= (n + 1);",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "SODFormula"
  },

  "SNOD": {
    "prefix": "SNOD",
    "body": [
      "ll SNOD(ll n)",
      "{",
      "    ll ans = 0, u = sqrt(n);",
      "    for (int i = 1; i <= u; i++)",
      "    {",
      "        ans += (n / i) - i;",
      "    }",
      "    ans *= 2;",
      "    ans += u;",
      "    return ans;",
      "}"
    ],
    "description": "Sum of Number of Divisors from 1 to N"
  },

  "isprime": {
    "prefix": "isprime",
    "body": [
      "bool isPrime(int n)",
      "{",
      "    if (n <= 1)",
      "        return false;",
      "    if (n <= 3)",
      "        return true;",
      "    if (n % 2 == 0 || n % 3 == 0)",
      "        return false;",
      "    for (int i = 5; i * i <= n; i = i + 6)",
      "        if (n % i == 0 || n % (i + 2) == 0)",
      "            return false;",
      "  ",
      "    return true;",
      "}"
    ],
    "description": "isprime"
  },
  "SieveOfEratosthenes": {
    "prefix": "sieve",
    "body": [
      "",
      "bitset<mx> is_prime;",
      "vector<int> primes;",
      "",
      "void Sieve(int n)",
      "{",
      "    for (int i = 3; i <= n; i += 2)",
      "    {",
      "        is_prime[i] = 1;",
      "    }",
      "",
      "    for (int i = 3; (i * i) <= n; i += 2)",
      "    {",
      "        if (is_prime[i])",
      "        {",
      "            for (int j = (i * i); j <= n; j += (i + i))",
      "            {",
      "                is_prime[j] = 0;",
      "            }",
      "        }",
      "    }",
      "",
      "    is_prime[1] = 0;",
      "    is_prime[2] = 1;",
      "    primes.push_back(2);",
      "",
      "    for (int i = 3; i <= n; i += 2)",
      "    {",
      "        if (is_prime[i])",
      "        {",
      "            primes.push_back(i);",
      "        }",
      "    }",
      "}",
      ""
    ],
    "description": ""
  },
  "primefactorization": {
    "prefix": "primefactorization",
    "body": [
      "vector<ll> PrimeFactors;",
      "",
      "void PrimeFactorization(ll n)",
      "{",
      "    PrimeFactors.clear();",
      "    // Call Sieve Function First",
      "    for (auto p : primes)",
      "    {",
      "        if (1LL * p * p > n)",
      "        {",
      "            break;",
      "        }",
      "        else if (n % p == 0)",
      "        {",
      "            while (n % p == 0)",
      "            {",
      "                PrimeFactors.push_back(p);",
      "                n /= p;",
      "            }",
      "        }",
      "    }",
      "    if (n > 1)",
      "    {",
      "        PrimeFactors.push_back(n);",
      "    }",
      "}"
    ],
    "description": "primefector"
  },
  "OneToNPrimeFactorization": {
    "prefix": "OneToNPrimeFactorization",
    "body": [
      "",
      "vector<vector<ll>> PrimeFactors(mx);",
      "",
      "void PrimeFactorization(ll n)",
      "{",
      "    // Call Sieve Function First",
      "    for (auto p : primes)",
      "    {",
      "        for (int i = p; i <= n; i += p)",
      "        {",
      "            PrimeFactors[i].push_back(p);",
      "        }",
      "    }",
      "",
      "    // for (int i = 1; i <= n; i++)",
      "    // {",
      "    //     cout << i << \" : \";",
      "    //     for (auto u : PrimeFactors[i])",
      "    //     {",
      "    //         cout << u << ' ';",
      "    //     }",
      "    //     cout << endl;",
      "    // }",
      "}"
    ],
    "description": "OneToNPrimeFactorization"
  },

  "lcm": {
    "prefix": "lcm",
    "body": [
      "ll int lcm(ll int a, ll int b) ",
      "{",
      "  return (a / gcd(a, b)) * b;",
      "  ",
      "  //return (a / __gcd(a, b)) * b;",
      "}"
    ],
    "description": "lcm"
  },
  "ModularArithmetic": {
    "prefix": "ModularArithmetic",
    "body": [
      "void normal(ll &a)",
      "{",
      "    a %= mod;",
      "    (a < 0) && (a += mod);",
      "}",
      "ll modMul(ll a, ll b)",
      "{",
      "    a %= mod, b %= mod;",
      "    normal(a), normal(b);",
      "    return (a * b) % mod;",
      "}",
      "ll modAdd(ll a, ll b)",
      "{",
      "    a %= mod, b %= mod;",
      "    normal(a), normal(b);",
      "    return (a + b) % mod;",
      "}",
      "ll modSub(ll a, ll b)",
      "{",
      "    a %= mod, b %= mod;",
      "    normal(a), normal(b);",
      "    a -= b;",
      "    normal(a);",
      "    return a;",
      "}",
      "ll modPow(ll b, ll p)",
      "{",
      "    ll r = 1;",
      "    while (p)",
      "    {",
      "        if (p & 1)",
      "        {",
      "            r = modMul(r, b);",
      "        }",
      "        b = modMul(b, b);",
      "        p >>= 1;",
      "    }",
      "    return r;",
      "}",
      "ll modInverse(ll a)",
      "{",
      "    return modPow(a, mod - 2);",
      "}",
      "ll modDiv(ll a, ll b)",
      "{",
      "    return modMul(a, modInverse(b));",
      "}"
    ],
    "description": "ModularArithmetic"
  },
  "BinaryExponentiation": {
    "prefix": "BinaryExponentiation",
    "body": [
      "int BinaryExponentiation(int b, int p)",
      "{",
      "    int ans = 1;",
      "    while (p)",
      "    {",
      "        if (p & 1)",
      "        {",
      "            ans = (ans * 1LL * b) % mod;",
      "        }",
      "        b = (b * 1LL * b) % mod;",
      "        p >>= 1;",
      "    }",
      "    return ans;",
      "}"
    ],
    "description": "BinaryExponentiation"
  },
  "EulerPhiFunction": {
    "prefix": "EulerPhiFunction",
    "body": [
      "int EulerPhi(int n)",
      "{",
      "    int ans = n;",
      "    for (auto p : primes)",
      "    {",
      "        if (p * 1LL * p > n)",
      "        {",
      "            break;",
      "        }",
      "        if (n % p == 0)",
      "        {",
      "            ans /= p;",
      "            ans *= (p - 1);",
      "            while (n % p == 0)",
      "            {",
      "                n /= p;",
      "            }",
      "        }",
      "    }",
      "",
      "    if (n > 1)",
      "    {",
      "        ans /= n;",
      "        ans *= (n - 1);",
      "    }",
      "",
      "    return ans;",
      "}"
    ],
    "description": "EulerPhiFunction"
  },
  "Graph Array": {
    "prefix": "grparr",
    "body": [
      "vector<ll int>adj[maxx];",
      "bool vis[maxx];",
      "//int level[maxx];"
    ],
    "description": "Graph Array"
  },
  "Graph Input": {
    "prefix": "grpin",
    "body": [
      "ll int node,edge;",
      "cin>>node>>edge;",
      "for(ll int i=0;i<edge;i++)",
      "{",
      "    ll int n1,n2; ",
      "    cin>>n1>>n2;",
      "    adj[n1].push_back(n2);",
      "    adj[n2].push_back(n1); ",
      "}"
    ],
    "description": "Graph Input"
  },

  "Graph Output": {
    "prefix": "grpout",
    "body": [
      "for(int i=0;i<node;i++)",
      "{",
      "    cout<<\"Adjacent list of : \"<<i<<\"->\";",
      "    for(auto j:adj[i])",
      "    {",
      "        cout<<j<<\" \";",
      "    }",
      "    cout<<endl;",
      "}",
      ""
    ],
    "description": "Graph Output"
  },

  "Graph Clear": {
    "prefix": "grpclr",
    "body": [
      "for(int i=0;i<node;i++)",
      "{",
      "    adj[i].clear();",
      "    vis[i]=0;",
      "    //level[i]=0;",
      "}",
      ""
    ],
    "description": "Graph Clear"
  },

  "Graph With Cost": {
    "prefix": "grpcost",
    "body": [
      "//vector<pair<ll int,ll int>>adj[maxx];",
      "",
      "ll int node,edge;",
      "cin>>node>>edge;",
      "for(ll int i=0;i<edge;i++)",
      "{",
      "    ll int n1,n2,cost; ",
      "    cin>>n1>>n2>>cost;",
      "    adj[n1].push_back({n2,cost});",
      "    adj[n2].push_back({n1,cost}); ",
      "}",
      ""
    ],
    "description": "Graph With Cost"
  },

  "Graph With Cost Output": {
    "prefix": "grpcostout",
    "body": [
      "for(int i=0;i<node;i++)",
      "{",
      "    for(auto x:adj[i])",
      "    {",
      "        cout<<i<<sp<<x.fi<<\" weight \"<<x.se<<dl;",
      "    }",
      "    cout<<endl;",
      "}",
      ""
    ],
    "description": "Graph With Cost Output"
  },

  "2D Array Graph Validation": {
    "prefix": "isvalid",
    "body": [
      "bool vis[maxx][maxx];",
      "int dist[maxx][maxx];",
      "int dirx[8] = { -1, 0, 0, 1, -1, -1, 1, 1 };",
      "int diry[8] = { 0, 1, -1, 0, -1, 1, -1, 1 };",
      "",
      "bool isValid(int row, int col)",
      "{",
      "    if (row < 0 || col < 0 || row >= ROW || col >= COL)",
      "        return false;",
      "    if (vis[row][col])",
      "        return false;",
      "    return true;",
      "}"
    ],
    "description": "2D Array Graph Validation"
  },

  "BFS 2D Array": {
    "prefix": "bfs2d",
    "body": [
      "",
      "void bfs(int srcX, int srcY)",
      "{",
      "    queue<pair<int, int> > q;",
      "    q.push(make_pair(srcX, srcY));",
      "    dist[srcX][srcY]=0;",
      "    vis[srcX][srcY]=1;",
      "    ",
      "    //if(srcX==tarX && srcY==tarY)return;",
      "",
      "    while (!q.empty()) ",
      "    {",
      "        pair<int, int> curr = q.front();",
      "        q.pop();",
      "",
      "        int row = curr.first;",
      "        int col = curr.second;",
      "",
      "       for (int i = 0; i < 8; i++)",
      "        if(isValid(row+dirx[i],col+diry[i]))",
      "        {",
      "            int adjx = row + dirx[i];",
      "            int adjy = col + diry[i];",
      "",
      "            dist[adjx][adjy]=dist[row][col]+1;",
      "            vis[adjx][adjy]=1;",
      "",
      "            q.push({ adjx, adjy });",
      "        }",
      "    }",
      "}",
      ""
    ],
    "description": "BFS 2D Array"
  },

  "BFS List": {
    "prefix": "bfs",
    "body": [
      "void bfs (int src)",
      "{",
      "  queue < int >q;",
      "  q.push (src);",
      "  color[src] = true;",
      "  level[src] = 0;",
      "  while (!q.empty ())",
      "    {",
      "      int curr = q.front ();",
      "      q.pop ();",
      "    for (auto child:adj[curr])",
      "    {",
      "      if (color[child] == 0)",
      "        {",
      "          q.push (child);",
      "          level[child] = level[curr] + 1;   // current node",
      "          color[child] = 1;",
      "        }",
      "    }",
      "    }",
      "}"
    ],
    "description": "BFS List"
  },

  "Bipertide": {
    "prefix": "biper",
    "body": [
      "bool biper(int v,int c)",
      "{",
      "    color[v]=1;",
      "    col[v]=c;",
      "    for(int child:adj[v])",
      "    {",
      "        if(color[child==0])",
      "        {",
      "            if(biper(child,c^1)==false)return false;",
      "            else if(col[v]==col[child])return false;",
      "        }",
      "    }",
      "    return true;",
      "}"
    ],
    "description": "Bipertide"
  },

  "Cycle Detection": {
    "prefix": "cycledet",
    "body": [
      "bool cycledet(int node ,int par)",
      "{",
      "    vis[node]=1;",
      "    for(int child:adj[node])",
      "    {",
      "        if(vis[child]==0)",
      "        {",
      "            if(cycledet(child,node)==true)return true;",
      "        }",
      "        else ",
      "        if(child!=par)return true;",
      "    }",
      "    return false;",
      "}"
    ],
    "description": "Cycle Detection"
  },

  "Cycle detection for directed graph": {
    "prefix": "cycledet_dir",
    "body": [
      "",
      "bool st[maxx];",
      "bool cycledet(int node,int par)",
      "{",
      "    st[node]=1;",
      "    vis[node]=1;",
      "    for(int child:adj[node])",
      "    {",
      "        if(vis[child]==0)",
      "        {",
      "            if(cycledet(child,node)==true)return true;",
      "        }",
      "        if(st[child])return true;",
      "    }",
      "    st[node]=0;",
      "    return false;",
      "",
      "}"
    ],
    "description": "Cycle detection for directed graph"
  },

  "DFS 2D Array": {
    "prefix": "dfs2d",
    "body": [
      "",
      "void dfs(int srcX, int srcY)",
      "{",
      "    stack<pair<int, int> > st;",
      "    st.push(make_pair(srcX, srcY));",
      "    while (!st.empty()) ",
      "    {",
      "        pair<int, int> curr = st.top();",
      "        st.pop();",
      "        int row = curr.first;",
      "        int col = curr.second;",
      "        if (!isValid(row, col))",
      "            continue;",
      "",
      "        vis[row][col] = true;",
      "       // cnt++;",
      "",
      "       for (int i = 0; i < 4; i++)",
      "        {",
      "            int adjx = row + dirx[i];",
      "            int adjy = col + diry[i];",
      "            st.push({ adjx, adjy });",
      "        }",
      "    }",
      "}",
      "",
      ""
    ],
    "description": "DFS 2D Array"
  },

  "DFS List": {
    "prefix": "dfs",
    "body": [
      "void dfs(int v)",
      "{",
      "    vis[v]=1;",
      "    //cout<<v<< \"->\";",
      "    for(auto child:adj[v])",
      "    {",
      "        if(!vis[child]) dfs(child);",
      "    }",
      "}"
    ],
    "description": "DFS List"
  },

  "Sub Tree": {
    "prefix": "subtree",
    "body": [
      "/*given two nodes, find whether one node lies in the subtree of other node*/",
      "",
      "//node y is a subtree of node x",
      "//in time x > y",
      "//out time x < y",
      "",
      "int timer=1;",
      "bool subtree(int v)",
      "{",
      "vis[v]=1;",
      "in[v]=timer++;",
      "for(int child:adj[v])",
      "{",
      "if(vis[child]==0)subtree(child);",
      "}",
      "out[v]=timer++;",
      "",
      "}"
    ],
    "description": "Sub Tree"
  },

  "Longest Path": {
    "prefix": "longestpath",
    "body": [
      "int maxD,maxNode;",
      "void longestpath(int node,int d)",
      "{",
      "vis[node]=1;",
      "if(d>maxD)maxD=d,maxNode=node;",
      "",
      "for(int child :adj[node])",
      "{",
      "if(vis[child]==0)",
      "{",
      "longestpath(child,d+1)",
      "}",
      "}",
      "}",
      "",
      "//For Main Function",
      "int main()",
      "// {",
      "// //***grp__input",
      "// maxD=-1;",
      "// longestpath(1,0);",
      "// memset(vis,0,sizeof(vis));",
      "// maxD=-1;",
      "// longestpath(maxNode,0);",
      "// cout<<maxD;",
      "// }"
    ],
    "description": "Longest Path"
  },

  "Sub Tree Size": {
    "prefix": "subtreesize",
    "body": [
      "int subtree(int node)",
      "{",
      "vis[node]=1;",
      "int curr_size=1;",
      "for(int child:adj[node])",
      "{",
      "if(vis[child]==0)",
      "{",
      "curr_size=curr_size+subtree(child)",
      "}",
      "subsize[node]=curr_size;",
      "return curr_size;",
      "}",
      "}"
    ],
    "description": "Sub Tree Size"
  },

  "Finding Bridegs": {
    "prefix": "findbridge",
    "body": [
      "int in[maxx],low[maxx];",
      "bool vis[maxx];",
      "int timer=0;",
      "void dfs (int node,int par) //dfs(1,-1)",
      "{",
      "    vis[node]=1;",
      "    in[node]=low[node]=timer++;",
      "    for(int child : adj[node])",
      "    {",
      "        if(child==par)continue;",
      "        if(vis[child]==1)",
      "        {",
      "            //edge node - child is a back edge",
      "            low[node]=min(low[node],in[child]);",
      "        }",
      "        else",
      "        {",
      "            // edge node -child forward edge",
      "            dfs(child,node);",
      "            if(low[child]>in[node])",
      "                cout<<node<<sp<<child<<\" is  a Brideges\"<<endl;",
      "",
      "            low[node]=min(low[node],in[child]);",
      "        }",
      "    }",
      "}",
      "",
      ""
    ],
    "description": "Finding Bridegs"
  },
  "First Occourence": {
    "prefix": "firstoccur",
    "body": [
      "int first(int arr[], int x, int n)",
      "{",
      "int low = 0, high = n - 1, res = -1;",
      "while (low <= high)",
      "{",
      "int mid = (low + high) / 2;",
      "",
      "if (arr[mid] >= x)",
      "high = mid - 1,res=mid;",
      "else",
      "low = mid + 1;",
      "}",
      "return res;",
      "}"
    ],
    "description": "First Occourence"
  },

  "Last Occourence": {
    "prefix": "lastoccur",
    "body": [
      "",
      "int last(int arr[], int x, int n)",
      "{",
      "int low = 0, high = n - 1, res = -1;",
      "while (low <= high)",
      "{",
      "int mid = (low + high) / 2;",
      "if (arr[mid] <= x)",
      "res=mid,low = mid + 1;",
      "else",
      "high = mid - 1;",
      "}",
      "return res;",
      "}"
    ],
    "description": "Last Occourence"
  },
  "Binary Search": {
    "prefix": "binarysrc",
    "body": [
      "int binarysrc(vector<int> v, int q)",
      "{",
      "    int first = 0;",
      "    int last = v.size() - 1;",
      "",
      "    while (first <= last)",
      "    {",
      "        int mid = (first + last) / 2;",
      "        if (q == v[mid])",
      "        {",
      "            return mid;",
      "        }",
      "        else if (v[mid] < q)",
      "        {",
      "            first = mid + 1;",
      "        }",
      "        else if (v[mid] > q)",
      "        {",
      "            last = mid - 1;",
      "        }",
      "    }",
      "    return -1;",
      "}",
      ""
    ],
    "description": "Binary Search"
  },
  "Upper Bound": {
    "prefix": "upperbound",
    "body": [
      "int upperbound(vector<int> v, int q)",
      "{",
      "    int l = 0, r = v.size() - 1, ans =v.size();",
      "    while (l <= r)",
      "    {",
      "        int mid = (l + r) >> 1;",
      "        if (v[mid] <= q)",
      "        {",
      "            l = mid + 1;",
      "        }",
      "        else",
      "        {",
      "            ans = min(ans, mid);",
      "            r = mid - 1;",
      "        }",
      "    }",
      "    return ans;",
      "}",
      ""
    ],
    "description": "Upper Bound"
  },
  "Lower Bound": {
    "prefix": "lowerbound",
    "body": [
      "int lowerbound(vector<int> v, int q)",
      "{",
      "    int l = 0, r = v.size() - 1, ans = v.size();",
      "    while (l <= r)",
      "    {",
      "        int mid = (l + r) >> 1;",
      "        if (v[mid] >= q)",
      "        {",
      "            ans = min(ans, mid);",
      "            r = mid - 1;",
      "        }",
      "        else",
      "        {",
      "            l = mid + 1;",
      "        }",
      "    }",
      "    return ans;",
      "}",
      ""
    ],
    "description": "Lower Bound"
  }
}
